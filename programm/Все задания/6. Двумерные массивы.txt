// Ilia Shemiakin, 2023
// Двумерные массивы

#include <iostream>
#include <iomanip>
#include <ctime>

// глобальные константы для массива постоянной размерности
const int N_ROW = 3;
const int N_COL = 5;

// Объявления функций (определения в конце файла)

// Функция, возвращающая максимум двумерного массива;
// обратите внимание, что в случае двумерного массива постоянной размерности (не динамического), 
// второй размер обязтельно(!) должен быть указан
// int array[][N_COL] - передаваемый массив
// int nRow - количество строк массива
// int nCol - количество столбцов массива
int getMaxValue(const int array[][N_COL], int nRow, int nCol);

// Функция возвращает среднее значение элементов двумерного массива постоянной размерности
// const int* array - указатель на первый элемент двумерного массива
// int nRow - количество строк массива
// int nCol - количество столбцов массива
double getAverage(const int* array, int nRow, int nCol);

// Функция выделяет динамическую память для двумерного массива
// int**& array - указатель на двумерный динамический массив, передаётся по ссылке
// int nRow - количество строк массива
// int nCol - количество столбцов массива
void allocateArray(int**& array, int nRow, int nCol);

// Функция освобождает динамическую память, выделеную для двумерного массива
// int** array - указатель на двумерный динамический массив
// int nRow - количество строк массива
void deallocateArray(int** array, int nRow);

// Функция меняет местами две строки матрицы без непосредственного перемещения элементов в памяти
// !!! защиты от выхода из допустимого диапазона номеров нет
// int** array - указатель на двумерный динамический массив
// int iLine1 - индекс первой строки
// int iLine2 - индекс второй строки
void swapRows(int** array, int iLine1, int iLine2);

int main()
{
  std::srand(std::time(0));

  // Поиск максимума двумерного массива (матрицы)

  // объявление двумерного массива с N_ROW строками и N_COL столбцами
  int matrix[N_ROW][N_COL];

  // задание значений элементов массива и вывод на экран
  for (int i = 0; i < N_ROW; ++i)
  {
    for (int j = 0; j < N_COL; ++j)
    {
      matrix[i][j] = std::rand() % 100 - 50;
      std::cout << std::setw(4) << matrix[i][j];
    }
    std::cout << '\n';
  }
  std::cout << '\n';

  std::cout << "Max element of matrix is " << getMaxValue(matrix, N_ROW, N_COL) << '\n';

  std::cout << '\n';

  // Передача двумерного массива в функцию при помощи указателя на его первый элемент (хак)

  const int N_ARRAY = 5;
  int matrix2[N_ARRAY][N_ARRAY];

  for (int i = 0; i < N_ARRAY; ++i)
  {
    for (int j = 0; j < N_ARRAY; ++j)
    {
      matrix2[i][j] = std::rand() % 10;
      std::cout << std::setw(2) << matrix2[i][j];
    }
    std::cout << '\n';
  }

  // вывод среднего значения элементов массива
  std::cout << "average value: " << getAverage(*matrix2, N_ARRAY, N_ARRAY) << '\n';
  // обратите внимание на то, что в функцию передаётся *matrix2, а не matrix2;
  // *matrix2 имеет тип int* (чего и требует наша функция),
  // тогда как matrix2 имеет тип int(*)[N_ARRAY], т.е. "указатель на массив int размером N_ARRAY"

  std::cout << '\n';

  // Создание динамического двумерного массива и передача его в функцию

  int nRow = 7;		// размеры массива (переменные!)
  int nCol = 5;

  // объявление указателя на указатель на int (адрес двумерного массива)
  int** dynTwoArray = nullptr;
  // при выделении памяти может возникнуть исключение bad_alloc,
  // поэтому работу с массивом производим в блоке try, чтобы избежать утечек памяти
  try {
    // выделение памяти
    allocateArray(dynTwoArray, nRow, nCol);

    // задание значений элементов массива и вывод на экран
    for (int i = 0; i < nRow; ++i)
    {
      for (int j = 0; j < nCol; ++j)
      {
        dynTwoArray[i][j] = std::rand() % 100;   // соответственно *(*(dynTwoArray + i) + j) эквивалентно dynTwoArray[i][j]
        std::cout << std::setw(3) << dynTwoArray[i][j];
      }
      std::cout << '\n';
    }

    std::cout << '\n';

    // поменяем местами вторую и шестую строки матрицы (индексы начинаются с 0)
    swapRows(dynTwoArray, 1, 5);

    for (int i = 0; i < nRow; ++i)
    {
      for (int j = 0; j < nCol; ++j)
      {
        std::cout << std::setw(3) << dynTwoArray[i][j];
      }
      std::cout << '\n';
    }
    std::cout << std::endl;
  }
  // перехватываем любые возможные исключения и выводим сообщение об ошибке
  catch (...)
  {
    std::cerr << "Error!\n";
  }

  // освобождение памяти
  deallocateArray(dynTwoArray, nRow);

  return 0;
}

// Функция, возвращающая максимум двумерного массива;
// обратите внимание, что в случае двумерного массива постоянной размерности (не динамического), 
// второй размер обязтельно(!) должен быть указан
// int array[][N_COL] - передаваемый массив
// int nRow - количество строк массива
// int nCol - количество столбцов массива
int getMaxValue(const int array[][N_COL], int nRow, int nCol)
{
  int maxValue = array[0][0];
  for (int i = 0; i < nRow; ++i)
  {
    for (int j = 0; j < nCol; ++j)
    {
      if (array[i][j] > maxValue)
      {
        maxValue = array[i][j];
      }
    }
  }
  return maxValue;
}

// Функция возвращает среднее значение элементов двумерного массива.
// Обратите внимание, что размеры массива передаются функции как параметры, а не жёстко указываются в объявлении.
// Стоит вспомнить, что двумерный массив представляет собой массив одномерных массивов,
// а его элементы располагаются в памяти последовательно.
// Первый аргумент функции типа int* будем понимать, как указатель на первый элемент первого одномерного массива.
// Именно поэтому в функцию из main был передан *matrix2, а не matrix2,
// т.к. matrix2 представляет собой указатель на первый одномерный массив, а не на первый элемент
// const int* array - указатель на первый элемент двумерного массива
// int nRow - количество строк массива
// int nCol - количество столбцов массива
double getAverage(const int* array, int nRow, int nCol)
{
  double sum = 0;
  for (int i = 0; i < nRow; ++i)
  {
    for (int j = 0; j < nCol; ++j)
    {
      // вычисляем адрес элемента array[i][j] как адрес начала массива (array) плюс 
      // смещение на кол-во строк (nCol * i) плюс смещение внутри строки (j)
      sum += *(array + nCol * i + j);
    }
  }
  return sum / nRow / nCol;
}

// Функция выделяет динамическую память для двумерного массива
// int**& array - указатель на двумерный динамический массив, передаётся по ссылке
// int nRow - количество строк массива
// int nCol - количество столбцов массива
void allocateArray(int**& array, int nRow, int nCol)
{
  // выделение памяти на массив из nRow указателей на int; new вернёт int**
  // массив будет инициализирован нулями (C++11);
  // это нужно для того, чтобы в случае, если при выделении памяти под строки возникнет bad_alloc,
  // можно было бы безопасно применить delete[] к указателям nullptr
  array = new int* [nRow] {nullptr};
  // выделение памяти для каждой строки массива
  for (int i = 0; i < nRow; ++i)
  {
    array[i] = new int[nCol];           // можно и *(array + i) = new int[nCol]; 
                                        // выражения *(array + i) и array[i] эквивалентны
  }
}

// Функция освобождает динамическую память, выделеную для двумерного массива
// int** array - указатель на двумерный динамический массив
// int nRow - количество строк массива
void deallocateArray(int** array, int nRow)
{
  // если указатель array пустой, то освобождать ничего не нужно
  if (array)
  {
    // освобождение памяти производится в порядке обратном выделению
    for (int i = 0; i < nRow; ++i)
    {
      delete[] array[i];
    }
    delete[] array;
  }
}

// Функция меняет местами две строки матрицы без непосредственного перемещения элементов в памяти
// !!! Защиты от выхода из допустимого диапазона номеров не сделано
// int** array - указатель на двумерный динамический массив
// int iLine1 - индекс первой строки
// int iLine2 - индекс второй строки
void swapRows(int** array, int iLine1, int iLine2)
{
  int* temp = array[iLine1];      // array[iLine1] аналогично *(array + iLine1); 
  array[iLine1] = array[iLine2];
  array[iLine2] = temp;
}
// эта функция прекрасно показывает, что указатели позволяют нам быстро логически перемещать
// большие объёмы данных без их физического переноса в памяти
