// Ilia Shemiakin, 2023
// Типы данных, переменные, операторы

#include <iostream>

// Использование пространства имён std на глобальном уровне не является хорошим тоном
// из-за возможных конфликтов с внутренними именами программы.
// ВАЖНО!!! Конструкция using namespace <name> недопустима на глобальном уровне
// в любых заголовочных файлах
// using namespace std;

int main()
{
    int a = 5;
    int b = 2;

    int n = 0;
    double c = 0.0;

    // Арифметические операции
    std::cout << "----- Arithmetic operations -----\n";
    // манипулятор endl и символ '\n' переводят курсор на новую строку
    std::cout << "a=5 - int, b=2 - int, n - int\n";
    n = a + b;
    std::cout << "n=a+b => n=" << n << std::endl;
    n = a - b;
    std::cout << "n=a-b => n=" << n << '\n';
    n = a * b;
    std::cout << "n=a*b => n=" << n << '\n';
    n = a % b;	//остаток от деления
    std::cout << "n=a%b => n=" << n << '\n';

    // с делением несколько сложнее
    // в операции "/" участвуют две переменные типа int => результат получается типа int,
    // т.е. 2,5 округляется до 2 (дробная часть просто отбрасывается);
    // то, что c имеет тип double - не важно
    c = a / b;
    std::cout << "c=a/b => c=" << c << '\n';

    std::cout << '\n';

    b = 6;
    c = a / b;	// дробная часть отбрасывается, а не округляется, т.е даже 5/6 превращаются в 0
    std::cout << "a=5 - int, b=6 - int, c - double\n"
        << "c=a/b => c=" << c << '\n';

    // чтобы сохранить точность используем явное преобразование типа одной из переменных (а),
    // причём к типу double переменная а приводится не навсегда, а только в этом выражении
    c = static_cast<double>(a) / b;
    std::cout << "c=static_cast<double>(a)/b => c=" << c << '\n';

    // то же самое в стиле языка C ("старый" способ, НЕ РЕКОМЕНДУЕТСЯ ИСПОЛЬЗОВАТЬ!!!)
    c = (double)a / b;
    std::cout << "c=(double)a/b => c=" << c << '\n';

    // точно так же с числами вместо переменных, т.к. целочисленные литералы имеют тот же тип int
    c = 5 / 6;
    std::cout << "c=5/6 => c=" << c << '\n';

    c = static_cast<double>(5) / 6;
    std::cout << "c=static_cast< double>(5)/6 => c=" << c << '\n';

    // в случае с литералами лучше использовать литералы типа double (5.0, 6.0)
    c = 5.0 / 6.0;
    std::cout << "c=5.0/6.0 => c=" << c << '\n';

    std::cout << '\n';

    std::cout << "----- Operator sizeof and conversion between double and int -----\n";
    // проверим размеры результатов выражений (описание sizeof см. в конце файла или в интернете)
    std::cout << "11/2=" << 11 / 2 << ", sizeof(11/2)=" << sizeof(11 / 2) << '\n';
    std::cout << "11.0/2=" << 11.0 / 2 << ", sizeof(11.0/2)=" << sizeof(11.0 / 2) << '\n';

    std::cout << '\n';

    double d = 3.3;
    std::cout << "a=5 - int, b=6 - int, d=3.3 - double, c - double\n";
    c = d * a / b;
    // здесь происходит неявное преобразование типов (без явного указания),
    // т.к. первой выполняется операция "*" (слева направо), то результат верный
    std::cout << "c=d*a/b => c=" << c << '\n';

    c = a / b * d;
    // т.к. первой выполняется операция "/" (слева направо), то 5/6=0, 0*3.3=0
    // от перестановки множителей результат меняется :)
    std::cout << "c=a/b*d => c=" << c << '\n';

    std::cout << '\n';

    c = 2.4;
    d = 3.3;
    n = c * d;	// результат c*d имеет тип double, но приводится к int, т.к. n переменная типа int
    std::cout << "c=2.4 - double, d=3.3 - double, n - int\n"
        << "n=c*d => n=" << n << ", c*d=" << c * d << '\n';

    std::cout << '\n';

    std::cout << "----- Operator priority -----\n";
    // порядок выполнения операций "+", "-", "*" и "/" правильный, как в математике,
    // скобки () меняют приоритет
    std::cout << "b - int" << '\n';
    b = 2 + 2 * 2;
    std::cout << "b=2+2*2 => b=" << b << '\n';

    b = 2 * 2 + 2;
    std::cout << "b=2*2+2 => b=" << b << '\n';

    b = (2 + 2) * 2;
    std::cout << "b=(2+2)*2 => b=" << b << '\n';

    std::cout << '\n';

    std::cout << "----- Assignment Operators -----\n";
    // Сокращённая запись арифметических операторов +=, -=, *=, /=, %=

    std::cout << "a=5 - int, c=5 - double\n";
    a = 5;
    a = a + 2;	// увеличиваем значение переменной a на 2
    // обратите внимание, оператор "=" означает не "равно", а "присвоить",
    // т.е. выражение "a = a + 2" означает не "а равно а плюс 2", 
    // а "переменной а присвоить новое значение, равное текущему плюс 2"
    std::cout << "a=a+2 => a=" << a << '\n';

    a = 5;
    a += 2;	// "a += b" аналогично "a = a + b"
    std::cout << "a+=2 => a=" << a << '\n';

    a = 5;
    a -= 2;
    std::cout << "a-=2 => a=" << a << '\n';

    a = 5;
    a *= 2;
    std::cout << "a*=2 => a=" << a << '\n';

    a = 5;
    a /= 2;	// не забываем о приведении типов
    std::cout << "a/=2 => a=" << a << '\n';

    c = 5;
    c /= 2;	// поэтому ещё раз
    std::cout << "c/=2 => c=" << c << '\n';

    a = 5;
    a %= 2;
    std::cout << "a%=2 => a=" << a << '\n';

    std::cout << '\n';

    std::cout << "----- Increment and decrement -----\n";
    // Инкремент и декремент
    // операции инкрементирования (увеличения на 1) и декрементирования (уменьшения на 1)
    // выполняются так часто, что для них сделали отдельные операторы "++" и "--"
    a = 1;
    a++;	// аналогично a = a + 1
    std::cout << "a=1 -> a++ => a=" << a << '\n';

    a = 10;
    a--;	// аналогично a = a - 1
    std::cout << "a=10 -> a-- => a=" << a << '\n';

    // существуют префиксная и постфиксная формы операторов "++" и "--": ++a, a++, --a, a--
    a = 10;
    b = 10 * ++a;	// в префиксной форме сначала выполняется инкремент, а потом остальные действия
    std::cout << "a=10, b=10*++a => a=" << a << ", b=" << b << '\n';

    a = 10;
    b = 10 * a++;	// в постфиксной форме создаётся копия переменной, затем значение переменной увеличивается,
                    // а в выражении используется значение копии
    std::cout << "a=10, b=10*a++ => a=" << a << ", b=" << b << '\n';

    // с декрементом аналогично, попробуйте сами;

    // Стоит избегать применения операторов "++" и "--" внутри сложных выражений
    // из-за сложностей определения порядка действий,  лучше вынести инкремент/декремент в отдельную строку

    std::cout << '\n';

    std::cout << "----- Type length -----\n";
    // Типы данных
    // операндом sizeof может быть имя типа, переменная или выражение,
    // результат - длина (в памяти) в размерах типа char (в "попугаях"), т.е. sizeof(char)==1 всегда
    std::cout << "sizeof(char)="  << sizeof(char) << '\n'
        << "sizeof(int)="         << sizeof(int) << '\n'
        << "sizeof(short)="       << sizeof(short) << '\n'
        << "sizeof(long)="        << sizeof(long) << '\n'
        << "sizeof(long long)="   << sizeof(long long) << '\n'
        << "sizeof(double)="      << sizeof(double) << '\n'
        << "sizeof(float)="       << sizeof(float) << '\n'
        << "sizeof(long double)=" << sizeof(long double) << '\n'
        << "sizeof(bool)="        << sizeof(bool) << '\n';

    std::cout << '\n';

    std::cout << "----- Conversions between int and bool -----\n";
    // Тип bool
    // преобразование bool в int
    bool e = true;
    std::cout << "e - bool, a - int" << '\n';
    a = e;
    std::cout << "a=e (e=true) => a=" << a << '\n';

    e = false;
    a = e;
    std::cout << "a=e (e=false) => a=" << a << '\n';

    // использование bool
    a = 100;
    b = 10;
    e = b > a;
    // при выводе на экран bool преобразуется в int (true - 1, false - 0),
    // это можно изменять с помощью манипуляторов boolalpha/noboolalpha
    std::cout << "a=100 - int,  b=10 - int, e - bool\n"
        << "e=b>a => e=" << std::boolalpha << e << std::noboolalpha << '\n';

    e = b < a;
    std::cout << "e=b<a => e=" << e << '\n';

    std::cout << '\n';

    // преобразование int в bool
    // 0 преобразуется в false остальные значения в true
    a = -100;
    e = a;
    std::cout << "a=-100 - int, e - bool\n"
        << "e=a => e=" << e << '\n';

    std::cout << '\n';

    a = 0;
    e = a;
    std::cout << "a=0 - int, e - bool\n"
        << "e=a => e=" << e << '\n';

    std::cout << '\n';

    std::cout << "----- char conversions -----\n";
    // Тип char
    // переменные char указываются в апострофах (а не в кавычках, как строковые литералы)
    char ch = 'a';
    std::cout << "ch=" << ch << '\n';	// строка в кавычках, кстати, воспринимается как неизменяемый массив символов char

    // при преобразовании char в int ASCII код символа становится числом;
    // при преобразовании int в char значение интерпретируется как ASCII код (обрезается до одного байта)
    std::cout << "static_cast<int>(ch)=" << static_cast<int>(ch) << '\n';
    std::cout << "static_cast<char>(98)=" << static_cast<char>(98) << '\n';

    std::cout << '\n';

    // тип char также содержит управляющие символы, начинающиеся с "\"
    // '\a'     звонок
    // '\b'     возврат на один символ назад
    // '\f'     перевод страницы
    // '\n'     новая строка
    // '\r'     перевод каретки
    // '\t'     горизонтальная табуляция
    // '\v'     вертикальная табуляция
    // '\''     апостроф
    // '\"'     двойные кавычки
    // '\\'     обратная дробная черта
    // '\?'     вопросительный знак
    std::cout << "new\nline" << std::endl
        << "slash - \\" << std::endl
        << "apostrophe - \'" << std::endl;
    // и т.д.

    std::cout << '\n';

    // раскомментируйте строки ниже, чтобы увидеть всю таблицу ASCII
    //for (int i = 0; i <= 255; i++)
    //{
    //	  ch = i;
    //	  std::cout << "ASCII[" << i << "]=" << ch << '\n';
    //}

    return 0;
}
