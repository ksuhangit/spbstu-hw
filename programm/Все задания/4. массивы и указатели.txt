// Ilia Shemiakin, 2023
// Массивы

#include <iostream>
#include <iomanip>	// для манипулятора setw()
#include <vector>

#include <cmath>    // для функции sqrt(), которая возвращает квадратный корень аргумента
#include <ctime>    // для установки генератора случайных чисел: функции time(0), rand()

// Объявления функций (определения в конце файла)
// Для указания размера массива можно также использовать беззнаковые типы
// unsigned int или size_t, но в любом случае, если размер указан неверно,
// то проверить это внутри функции невозможно

// Функция сортировки массива по убыванию методом выбора
// int* array - передаваемый массив
// int n - количество элементов массива
void selectionSort(int* array, int n);    // можно и так: void selectionSort(int array[], int n);

// Функция сортировки массива по возрастанию методом пузырька
// int* array - передаваемый массив
// int n - количество элементов массива
void bubbleSort(int* array, int n);

// Функция, возвращающая евклидову норму вектора (она же длина n-мерного вектора) 
// norm_e=(v1^2+v2^2+v3^2+...+vn^2)^(1/2)
// const double* array - передаваемый массив
// int n - количество элементов массива
// здесь const зпрещает изменение элементов массива внутри функции
double euklidNorm(const double* array, int n);

// Функция возвращает сумму элементов массива std::vector<>
// const std::vector<int>& array - передаваемый массив
int getSum(const std::vector<int>& array);

int main()
{
    // установка генератора псевдослучайных чисел; функция time(0) объявлена в <ctime>
    std::srand(std::time(0));

    // Указатели

    // Указатель - это переменная, значением которой является адрес в памяти.
    // При работе с типизированным указателем мы можем получать доступ как к самому адресу,
    // так и к значению, находящемуся по этому адресу.

    int ivar1 = 10;
    int *iptr1 = &ivar1;	// объявление и инициализация указателя значением адреса переменной var1
    int *iptr2(&ivar1);		// другой вариант (равнозначный) объявления и инициализации указателя
    int *iptr3 = iptr1;		// объявление и инициализация указателя значением другого указателя
    // здесь:
    // переменная ivar1 имеет тип int,
    // выражение &ivar1 возвращает адрес переменной ivar1 (т.е. значение типа int*),
    // переменная iptr1 имеет тип int* (указатель на int),
    // выражение *iptr1 возвращает значение по адресу из iptr1 (т.е. значение типа int, показано ниже)

    // выведем все переменные и адреса
    std::cout << "&var1=" << &ivar1 << ", var1=" << ivar1 << '\n'
        << "ptr1=" << iptr1 << ", *ptr1=" << *iptr1 << '\n'
        << "ptr2=" << iptr2 << ", *ptr2=" << *iptr2 << '\n'
        << "ptr3=" << iptr3 << ", *ptr3=" << *iptr3 << '\n';
    std::cout << std::endl;

    *iptr3 = 20;	// изменение значения по адресу
    std::cout << "&var1=" << &ivar1 << ", var1=" << ivar1 << '\n'
        << "ptr1=" << iptr1 << ", *ptr1=" << *iptr1 << '\n'
        << "ptr2=" << iptr2 << ", *ptr2=" << *iptr2 << '\n'
        << "ptr3=" << iptr3 << ", *ptr3=" << *iptr3 << '\n';
    std::cout << std::endl;

    double dvar1 = 2.5;
    // указателю на void (типу void*) можно присвоить значение уазателя на любой другой тип;
    // разыменовывать указатель void* нельзя,
    // т.к. компилятор не может знать, как интерпретировать значение по данному адресу
    void* vptr = &dvar1;
    // использовать указатель void* можно совместно с явным приведением типов
    double* dptr1 = static_cast<double*>(vptr);
    std::cout << "vptr=" << vptr << ", *(static_cast<double*>(vptr))=" << *(static_cast<double*>(vptr)) << '\n'
        << "&dvar1=" << &dvar1 << ", dvar1=" << dvar1 << '\n'
        << "dptr1=" << dptr1 << ", *dptr1=" << *dptr1 << '\n';
    std::cout << std::endl;

    // Массивы

    const int N_FOO_ARRAY = 10;
    // объявление массива с инициализацией;
    // неуказанные в инициализаторе элементы заполняются нулями (но только если инициализатор есть!)
    int foo[N_FOO_ARRAY]{ 1, 2, 3, 4, 5 };
    // если размер не указан явно, он вычисляется из инициализатора
    int bar[]{ 4, 3, 2, 1 };

    // количество элементов в массиве можно вычислить с помощью оператора sizeof,
    // но это возможно только когда доступен сам массив, а не указатель на его первый элемент
    std::cout << "Size of bar is " << sizeof(bar) / sizeof(bar[0]) << '\n';

    // имя массива может быть использовано в качестве указателя на его первый элемент
    std::cout << "Address of foo: " << foo << '\n';
    std::cout << "First element of foo : " << *foo << '\n';

    // к элементам массива можно обращаться с помощью оператора индексации foo[i],
    // а можно с помощью адресной арифметики *(foo + i),
    // что для компилятора - одно и то же
    std::cout << "foo[2]: " << foo[2] << '\n';
    std::cout << "*(foo + 2): " << *(foo + 2) << '\n';

    std::cout << '\n';

    // Сортировка массива выбором

    const int N_FIRST_ARRAY = 10;
    int firstArray[N_FIRST_ARRAY];

    std::cout << "Selection sort\n";
    // инициализация массива случайными числами от -50 до 49;
    // функция rand() используется для получения псевдослучайных чисел в диапазоне от 0 до RAND_MAX
    // константа RAND_MAX определена в stdlib
    for (int i = 0; i < N_FIRST_ARRAY; ++i)
    {
        firstArray[i] = std::rand() % 100 - 50;
    }

    // вывод массива
    std::cout << "Array before sorting: ";
    for (int i = 0; i < N_FIRST_ARRAY; ++i)
    {
        std::cout << std::setw(4) << firstArray[i];
    }
    std::cout << '\n';

    // сортировка массива методом выбора максимума;
    // в функцию передаётся только имя массива,
    // массив при передаче в функцию не копируется, после работы функции массив остаётся изменённым
    selectionSort(firstArray, N_FIRST_ARRAY);

    std::cout << "Array after sorting: ";
    for (int i = 0; i < N_FIRST_ARRAY; ++i)
    {
        std::cout << std::setw(4) << firstArray[i];
    }
    std::cout << "\n\n";

    // Вычисление евклидовой нормы вектора

    const int N_SECOND_ARRAY = 3;
    double secondArray[N_SECOND_ARRAY];

    for (int i = 0; i < N_SECOND_ARRAY; ++i)
    {
        secondArray[i] = std::rand() % 41 - 20;
    }

    std::cout << "Vector:";
    for (int i = 0; i < N_SECOND_ARRAY; ++i)
    {
        std::cout << std::setw(4) << secondArray[i];
    }
    std::cout << "  Norm: " << euklidNorm(secondArray, N_SECOND_ARRAY);

    std::cout << "\n\n";

    // Динамическое выделение памяти. Сортировка пузырьком

    std::cout << "Bubble sort\n";

    int nDynArray = 15;	// размер массива (переменная!)

    // выделение памяти под массив из nDynArray элементов типа int
    // и помещение указателя на эту память в переменную-указатель dynArray;
    int* dynArray = new int[nDynArray];

    for (int i = 0; i < nDynArray; ++i)
    {
        dynArray[i] = std::rand() % 10;
    }

    std::cout << "Array before sorting: ";
    for (int i = 0; i < nDynArray; ++i)
    {
        std::cout << std::setw(3) << dynArray[i];
    }
    std::cout << '\n';

    // обратите внимание, что функция не знает, в какой области памяти находятся элементы массива
    // и может работать как с динамическим массивом, так и с обычным
    bubbleSort(dynArray, nDynArray);

    std::cout << "Array after sorting: ";
    for (int i = 0; i < nDynArray; ++i)
    {
        std::cout << std::setw(3) << dynArray[i];
    }

    // оператор delete освобождает память, привязанную к указателю; 
    // для массивов требуются скобки delete[]
    delete[] dynArray;

    std::cout << "\n\n";

    // Динамические массивы vector из стандартной библиотеки шаблонов (STL; необходимо подключить <vector>) 

    std::vector<int> vectArray; // создаем массив целых чисел,
                                // синтаксис может сейчас казаться странным, но потом станет понятно почему так

    std::cout << "Vector(1) size: " << vectArray.size() << '\n';	// встроенный метод size возвращает размер массива

    for (int i = 0; i < 5; ++i)
    {
        vectArray.push_back(i);	// метод push_back помещает аргумент в конец массива
    }

    std::cout << "Vector(2): [";
    for (size_t i = 0; i < vectArray.size(); ++i)
    {
        std::cout << std::setw(4) << vectArray[i];
    }
    std::cout << "]; size: " << vectArray.size() << '\n';

    vectArray.push_back(5);
    vectArray.push_back(6);
    vectArray.insert(vectArray.begin() + 5, 15);	// vectArray.begin() - итератор (указатель) на начало массива

    // обратите внимание на то, что размер vector может меняться
    // посмотрите, куда вставился элемент 15
    std::cout << "Vector(3): [";
    for (size_t i = 0; i < vectArray.size(); ++i)
    {
        std::cout << std::setw(4) << vectArray[i];
    }
    std::cout << "]; size: " << vectArray.size() << '\n';

    std::cout << "Sum: " << getSum(vectArray) << '\n';

    return 0;
}

// Функция сортировки массива по убыванию методом выбора
// int* array - передаваемый массив (аналогично int array[])
// int n - количество элементов массива
// ВАЖНО!!! т.к. в функцию передаётся не массив, а только указатель на его первый элемент,
// внутри функции невозможно узнать размер массива с помощью оператора sizeof(),
// а таже использовать цикл по диапазону for (int i : array)
void selectionSort(int* array, int n)
{
    for (int i = 0; i < n - 1; ++i)	// i < n - 1, т.к. последний элемент отсортируется автоматически
    {
        // инициализируем iMax в начале каждого цикла первым элементом из оставшейся части массива
        int iMax = i;
        // ищем максимальный элемент в оставшейся части массива
        for (int j = i + 1; j < n; ++j)
        {
            if (array[j] > array[iMax])
            {
                iMax = j;
            }
        }
        // помещаем максимальный элемент на место первого элемента оставшейся части массива (меняем местами)
        if (iMax != i)
        {
            int temp = array[i];
            array[i] = array[iMax];
            array[iMax] = temp;
            // можно было бы использовать стандартную функцию std::swap
        }
    }
}

// Функция сортировки массива по возрастанию методом пузырька
// int* array - передаваемый массив
// int n - количество элементов массива
void bubbleSort(int* array, int n)
{
    for (int i = 0; i < n - 1; ++i)
    {
        for (int j = 0; j < n - i - 1; ++j)
        {
            // если текущий элемент больше следующего за ним, то меняем их местами
            if (array[j] > array[j + 1])
            {
                int temp = array[j];
                array[j] = array[j + 1];
                array[j + 1] = temp;
            }
        }
    }
}

// Функция, возвращающая евклидову норму вектора (она же длина n-мерного вектора) 
// norm_e=(v1^2+v2^2+v3^2+...+vn^2)^(1/2)
// const double* array - передаваемый массив
// int n - количество элементов массива
double euklidNorm(const double* array, int n)
{
    double res = 0;
    for (int i = 0; i < n; ++i)
    {
        res += array[i] * array[i];
    }
    return std::sqrt(res);  // функция sqrt() возвращает квадратный корень аргумента (описана в <cmath>)
}

// Функция возвращает сумму элементов массива std::vector<>
// const std::vector<int>& array - передаваемый массив
// массивы std::vector<>, как и другие объекты слдует передавать в функции по ссылкам, чтобы избежать копирования;
// размер массива отдельно передавать не нужно, т.к. объект std::vector<> содержит в себе эту информацию
int getSum(const std::vector<int>& array)
{
    int sum = 0;
    for (int n : array)
    {
        sum += n;
    }
    return sum;
}