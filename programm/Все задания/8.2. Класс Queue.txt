// Ilia Shemiakin, 2024
// Очередь

#include <iostream>

// Очередь - структура данных, работающая по принципу FIFO (First In, First Out),
// т.е. элементы извлекаются из очереди в том же порядке, в котором добавлялись.
// Ниже реализована очередь целых чисел на базе связного списка
class QueueInt
{
public:
    QueueInt() :
        head_(nullptr),
        tail_(nullptr)
    {}

    ~QueueInt()
    {
        while (head_)
        {
            Node* temp = head_;
            head_ = head_->next;
            delete temp;
        }
    }

    QueueInt(const QueueInt&);                   // конструктор копирования
    QueueInt(QueueInt&&) noexcept;               // конструктор перемещения
    QueueInt& operator=(const QueueInt&);        // перегруженный оператор присваивания
    QueueInt& operator=(QueueInt&&) noexcept;    // перегруженный оператор перемещающего присваивания

    void swap(QueueInt&) noexcept;               // обмен двух очередей значениями (используется в операторе присваивания)

    void put(int);                               // добавить элемент в очередь
    int take();                                  // получить элемент из очереди

    friend std::ostream& operator<<(std::ostream& stream, const QueueInt& queue);

private:
    struct Node           // элемент очереди
    {
        int data;             // данные
        Node* next;         // указатель на следующий элемент
    };

    Node* head_;          // указатель на начало очереди
    Node* tail_;          // указатель на конец очереди
};

// конструктор копирования
// кода объект класса содержит в себе какой-либо внешний ресурс (например, динамически выделенную память),
// необходимо(!) реализовать (или запретить) конструктор копирования, оператор присвивания и деструктор
// в C++11 желательно также определить конструктор перемещения и оператор перемещающего присваивания
QueueInt::QueueInt(const QueueInt& queue) :
    head_(nullptr),
    tail_(nullptr)
{
    // собираем копию очереди внутри временного объекта, чтобы не допустить утечки памяти
    // в случае возникновения исключения при выделени памяти под очередной элемент
    QueueInt temp;
    Node* src = queue.head_;
    while (src)
    {
        temp.put(src->data);
        src = src->next;
    }
    swap(temp);
}

// конструктор перемещения
QueueInt::QueueInt(QueueInt&& queue) noexcept :
    head_(nullptr),
    tail_(nullptr)
{
    swap(queue);
}

// оператор копирующего присваивания
QueueInt& QueueInt::operator=(const QueueInt& queue)
{
    // выполняем присваивание только если адреса объектов отличаются
    if (this != &queue)
    {
        // создаём копию присваиваемой очереди
        QueueInt tempQueue(queue);
        // меняем содержимое временной копии и контекстного объекта
        swap(tempQueue);
    }
    // возвращаем ссылку на контекстный объект
    return *this;

    // временный объект tempQueue будет уничтожен при завершении метода
    // и его деструктор освободит память, занятую элементами изначальной очереди;
    // такой приём написания оператора присваивания называется copy-and-swap
}

// оператор перемещающего присваивания
QueueInt& QueueInt::operator=(QueueInt&& queue) noexcept
{
    if (this != &queue)
    {
        // используем написанный ранее конструктор перемещения,
        // превращая queue в R-value с помощью функции move
        QueueInt tempQueue(std::move(queue));
        swap(tempQueue);
    }
    return *this;
}

// обмен значениями аргумента и контекстного объекта (просто меняем указатели)
void QueueInt::swap(QueueInt& queue) noexcept
{
    std::swap(head_, queue.head_);
    std::swap(tail_, queue.tail_);
}

// добавление элемента в очередь
void QueueInt::put(int d)
{
    if (!head_)
    {
        head_ = tail_ = new Node;
    }
    else
    {
        tail_->next = new Node;
        tail_ = tail_->next;
    }
    tail_->data = d;
    tail_->next = nullptr;
}

// извлечение элемента из очереди
int QueueInt::take()
{
    if (!head_)
    {
        throw std::logic_error("Queue is empty");
    }
    int res = head_->data;
    Node* temp = head_;
    if (head_ == tail_)
    {
        head_ = tail_ = nullptr;
    }
    else
    {
        head_ = head_->next;
    }
    delete temp;
    return res;
}

// вывод очереди на экран
std::ostream& operator<<(std::ostream& stream, const QueueInt& queue)
{
    QueueInt::Node* temp = queue.head_;
    while (temp)
    {
        std::cout << temp->data << '\n';
        temp = temp->next;
    }
    return stream;
}

int main()
{
    QueueInt queue;

    // добавляем в очередь элементы
    queue.put(8);
    queue.put(15);
    queue.put(16);
    queue.put(100);
    queue.put(-8);

    // выводим
    std::cout << "Start queue:\n";
    std::cout << queue;
    std::cout << '\n';

    // проверяем метод take, должно вернуться число, помещённое в очередь первым
    std::cout << "extract " << queue.take() << '\n';

    // ещё раз выводим
    std::cout << "Queue after first taking:\n";
    std::cout << queue;
    std::cout << '\n';

    QueueInt queue2 = queue;	// здесь вызывается конструктор копирования (эквивалентно QueueInt queue2(queue);)

    // извлекаем ещё один элемент из исходнй очереди
    std::cout << "extract " << queue.take() << '\n';

    // и выводим, чтобы показать, что очереди разные
    std::cout << "After second taking\n";
    std::cout << "queue:\n";
    std::cout << queue;
    std::cout << "\nqueue2:\n";
    std::cout << queue;
    std::cout << '\n';

    queue2 = queue;	// а вот здесь уже вызывается оператор присваивания

    std::cout << "queue2 after assignment:\n";
    std::cout << queue;
    std::cout << '\n';

    // попробуйте самостоятельно написать примеры применения конструктора перемещения
    // и оператора перемещающего присваивания

    // извлекаем оставшиеся элементы и один "лишний"
    try
    {
        std::cout << "extract " << queue.take() << '\n';
        std::cout << "extract " << queue.take() << '\n';
        std::cout << "extract " << queue.take() << '\n';
        std::cout << "extract " << queue.take() << '\n';    // здесь будет исключение
    }
    catch (const std::logic_error& e)
    {
        std::cerr << e.what() << '\n';
    }

    return 0;
}
