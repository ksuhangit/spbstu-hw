// В примере демонстрируются копирование и перемещение объектов.
// Сам класс не выполняет никакой полезной работы и содержит два поля:
// int *a_ - указатель на массив в динамической памяти; массив создаётся и инициализируется в конструкторе
// int id_ - идентификатор объекта; присваивается в конструкторах
// Все методы выводят на экран вспомогательную информацию, показывающую, какой метод и для какого объекта вызывается
// Попробуйте самостоятельно воспользоваться различными вариантами создания и использования объектов,
// чтобы посмотреть на работу конструкторов и операторов присваивания.
// Попробуйте закомментировать те или иные конструкторы и операторы присваивания, посмотрите, как изменится поведение программы

// Возврат объекта из функции (не по ссылке) должен вызывать создание временного объекта,
// но компилятор, в зависимости от настроек, может применять определённые в стандарте оптимизации copy/move elision
// и избегать создания ненужных объектов
// https://en.cppreference.com/w/cpp/language/copy_elision
// https://en.wikipedia.org/wiki/Copy_elision

#include <iostream>
#include <cmath>

class A
{
public:
  // Конструктор
  // Назначает объектам уникальный идентификатор с помощью статической переменной counter,
  // выделяет динамическую память под массив размера SIZE
  // и инициализирует его элементы значением id_
  // (просто чтобы видеть, что в массиве есть какие-то данные)
  A() :
    a_(new int[SIZE])
  {
    static int counter = 0;
    id_ = ++counter;
    for (int i = 0; i < SIZE; i++)
    {
      a_[i] = id_;
    }
    std::cout << "Constructor: " << id_ << '\n';
  }

  // Деструктор
  ~A()
  {
    delete[] a_;
    std::cout << "Destructor: " << id_ << '\n';
  }

  // Конструктор копирования
  // Копирует элементы массива в новую область памяти,
  // новый объект получает идентификатор на 100 больший, чем исходный
  A(const A& src) :
    id_(src.id_ + 100),
    a_(new int[SIZE])
  {
    for (int i = 0; i < SIZE; i++)
    {
      a_[i] = src.a_[i];
    }
    std::cout << "Copy constructor: " << src.id_ << " to " << id_ << '\n';
  }

  // Конструктор перемещения
  // Переносит массив из исходного объекта в новый,
  // новый объект получает идентификатор на 1000 больший, чем исходный
  A(A&& src) noexcept :
    id_(src.id_ + 1000),
    a_(src.a_)
  {
    src.a_ = nullptr;
    std::cout << "Move constructor: " << src.id_ << " to " << id_ << '\n';
  }

  // Оператор копирующего присваивания
  A& operator=(const A& src)
  {
    if (this != &src)
    {
      int* temp = a_;
      a_ = new int[SIZE];
      delete[] temp;
      for (int i = 0; i < SIZE; i++)
      {
        a_[i] = src.a_[i];
      }
      std::cout << "Copy assignment: " << src.id_ << " to " << id_ << '\n';
    }
    return *this;
  }

  // Оператор перемещающего присваивания
  A& operator=(A&& src) noexcept
  {
    if (this != &src)
    {
      delete[] a_;
      a_ = src.a_;
      src.a_ = nullptr;
      std::cout << "Move assignment: " << src.id_ << " to " << id_ << '\n';
    }
    return *this;
  }

  int getId() const
  {
    return id_;
  }

private:
  static const int SIZE = 10; // размер массива - статическая константа

  int id_;
  int* a_;
};

// Функции, принимающие и возвращающие объект типа A различным образом
// (можете дописать собственные)

A test(A x) {
  return x;
}

A& test2(A& x) {
  return x;
}

A test3()
{
  A a;
  return a;
}

A test4()
{
  return A();
}

int main()
{
  A a1;

  A a2 = test(a1);

  //std::cout << test(a1).getId() << '\n';

  //A a3 = a1;
  //A a4;
  //a4 = a1;

  // ... попробуйте свои варианты создания и использования объектов

  return 0;
}
